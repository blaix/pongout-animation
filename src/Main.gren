module Main exposing (main)

import Playground exposing (..)

type alias Model =
    { greenBall : Ball
    , blackBall : Ball
    , board : Array Brick
    }

type alias Ball =
    { x : Float
    , y : Float
    , dx : Float
    , dy : Float
    , color: Color
    }

type alias Brick =
    { x : Float
    , y : Float
    , color: Color
    }

squareSize = 20
ballSpeed = 3
maxX = 30
minX = -30
maxY = 15
minY = -15

main =
    game view update 
        { greenBall = 
            { color = green 
            , x = -15 * squareSize
            , y = -10 * squareSize
            , dx = 1
            , dy = 1
            }
        , blackBall =
            { color = black
            , x = 15 * squareSize
            , y = 10 * squareSize
            , dx = -1
            , dy = -1
            }
        , board =
            Array.range minX maxX
                |> Array.map
                    (\x ->
                        Array.range minY maxY
                            |> Array.map
                                (\y ->
                                    { x = x * squareSize |> toFloat
                                    , y = y * squareSize |> toFloat
                                    , color =
                                        if x < 0 then
                                            black
                                        else
                                            green
                                    }
                                )
                    )
                |> Array.flatten
        }

update : Computer -> Model -> Model
update computer model =
    let
        newGreen =
            { ball = model.greenBall, board = model.board }
                -- Move x and y separately since it's the easiest way to see if a
                -- collision happened on a side or on the top/bottom, which we need to
                -- know to change the x or y direction appropriately.
                |> moveBallX
                |> moveBallY

        newBlack =
            { ball = model.blackBall, board = newGreen.board }
                |> moveBallX
                |> moveBallY
    in
    { model
        | board = newBlack.board
        , greenBall = newGreen.ball
        , blackBall = newBlack.ball
    }

moveBallX : { ball : Ball, board : Array Brick } -> { ball : Ball, board : Array Brick }
moveBallX { ball, board } =
    let
        nextX = 
            ball.x + (ball.dx * ballSpeed)
        
        newBall =
            if nextX > (maxX * squareSize) || nextX < (minX * squareSize) then
                { ball | x = ball.x, dx = -ball.dx }
            else
                { ball | x = nextX, dx = ball.dx }

        hitBricks =
            board
                |> Array.filter
                    (\brick ->
                        newBall.color == brick.color &&
                        newBall.x < brick.x + squareSize &&
                        newBall.x + squareSize > brick.x &&
                        newBall.y < brick.y + squareSize &&
                        newBall.y + squareSize > brick.y
                    )

        newDx =
            if hitBricks == [] then
                newBall.dx
            else
                -newBall.dx

        newBoard =
            Array.map (swapColorIfHit hitBricks) board
    in
    { ball =
        { newBall | dx = newDx }
    , board =
        newBoard
    }

moveBallY : { ball : Ball, board : Array Brick } -> { ball : Ball, board : Array Brick }
moveBallY { ball, board } =
    let
        nextY = 
            ball.y + (ball.dy * ballSpeed)
        
        newBall =
            if nextY > (maxY * squareSize) || nextY < (minY * squareSize) then
                { ball | y = ball.y, dy = -ball.dy }
            else
                { ball | y = nextY, dy = ball.dy }

        hitBricks =
            board
                |> Array.filter
                    (\brick ->
                        newBall.color == brick.color &&
                        newBall.x < brick.x + squareSize &&
                        newBall.x + squareSize > brick.x &&
                        newBall.y < brick.y + squareSize &&
                        newBall.y + squareSize > brick.y
                    )

        newDy =
            if hitBricks == [] then
                newBall.dy
            else
                -newBall.dy

        newBoard =
            Array.map (swapColorIfHit hitBricks) board
    in
    { ball =
        { newBall | dy = newDy }
    , board =
        newBoard
    }

swapColorIfHit : Array Brick -> Brick -> Brick
swapColorIfHit hitBricks brick =
    if Array.member brick hitBricks then
        { brick | color = swapColor brick.color }
    else
        brick

swapColor : Color -> Color
swapColor color =
    if color == green then
        black
    else
        green

moveBall : Ball -> Ball
moveBall ball =
    let
        nextX = ball.x + (ball.dx * ballSpeed)
        nextY = ball.y + (ball.dy * ballSpeed)

        newX =
            if nextX > (maxX * squareSize) || nextX < (minX * squareSize) then
                { x = ball.x, dx = -ball.dx }
            else
                { x = nextX, dx = ball.dx }

        newY =
            if nextY > (maxY * squareSize) || nextY < (minY * squareSize) then
                { y = ball.y, dy = -ball.dy }
            else
                { y = nextY, dy = ball.dy }
    in
    { ball
        | x = newX.x
        , y = newY.y
        , dx = newX.dx
        , dy = newY.dy
    }

view : Computer -> Model -> Array Shape
view computer model =
    drawBoard model.board ++
        [ drawBall model.greenBall
        , drawBall model.blackBall
        ]

drawBoard : Array Brick -> Array Shape
drawBoard board =
    Array.map drawBrick board

drawBrick : Brick -> Shape
drawBrick brick =
    square brick.color squareSize
        |> moveX brick.x
        |> moveY brick.y

drawBall : Ball -> Shape
drawBall ball =
    square ball.color squareSize
        |> moveX ball.x
        |> moveY ball.y
